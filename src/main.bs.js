// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Js_array = require("rescript/lib/js/js_array.js");

function tokenizer(input) {
  var current = {
    contents: 0
  };
  var bumpCurrent = function (param) {
    current.contents = current.contents + 1 | 0;
  };
  var tokens = [];
  var numbersRe = /[0-9]/;
  var lettersRe = /[a-z]/i;
  while(current.contents < input.length) {
    var $$char = input[current.contents];
    var match = $$char;
    switch (match) {
      case "(" :
          tokens.push(/* TokenLeftParen */0);
          bumpCurrent(undefined);
          break;
      case ")" :
          tokens.push(/* TokenRightParen */1);
          bumpCurrent(undefined);
          break;
      case " " :
      case "\n" :
      case "\t" :
          bumpCurrent(undefined);
          break;
      default:
        if (numbersRe.test($$char)) {
          var value = "";
          while(numbersRe.test($$char)) {
            value = value + $$char;
            bumpCurrent(undefined);
            $$char = input[current.contents];
          };
          tokens.push({
                TAG: /* TokenNumber */0,
                _0: value
              });
        } else if (match === "\"") {
          var value$1 = "";
          bumpCurrent(undefined);
          while($$char !== "\"") {
            value$1 = value$1 + $$char;
            bumpCurrent(undefined);
            $$char = input[current.contents];
          };
          bumpCurrent(undefined);
          $$char = input[current.contents];
          tokens.push({
                TAG: /* TokenString */1,
                _0: value$1
              });
        } else if (lettersRe.test($$char)) {
          var value$2 = "";
          while(lettersRe.test($$char)) {
            value$2 = value$2 + $$char;
            bumpCurrent(undefined);
            $$char = input[current.contents];
          };
          tokens.push({
                TAG: /* TokenName */2,
                _0: value$2
              });
        } else {
          Js_exn.raiseTypeError("I dont know what this character is: " + $$char + "");
        }
    }
  };
  return tokens;
}

var LispAst = {};

var LispAstKind = {};

function parser(tokens) {
  var current = {
    contents: 0
  };
  var bumpCurrent = function (param) {
    current.contents = current.contents + 1 | 0;
  };
  var walk = function (param) {
    var token = {
      contents: tokens[current.contents]
    };
    var value = token.contents;
    if (typeof value === "number") {
      if (value === /* TokenLeftParen */0) {
        bumpCurrent(undefined);
        token.contents = tokens[current.contents];
        var name = token.contents;
        if (typeof name === "number") {
          throw {
                RE_EXN_ID: "Match_failure",
                _1: [
                  "main.res",
                  110,
                  20
                ],
                Error: new Error()
              };
        }
        if (name.TAG === /* TokenName */2) {
          var node_name = name._0;
          var node_params = [];
          var node = {
            name: node_name,
            params: node_params
          };
          bumpCurrent(undefined);
          token.contents = tokens[current.contents];
          while(token.contents !== /* TokenRightParen */1) {
            Js_array.push(walk(undefined), node_params);
            token.contents = tokens[current.contents];
          };
          bumpCurrent(undefined);
          return {
                  TAG: /* Call */0,
                  _0: node
                };
        }
        throw {
              RE_EXN_ID: "Match_failure",
              _1: [
                "main.res",
                110,
                20
              ],
              Error: new Error()
            };
      } else {
        console.log(token);
        return Js_exn.raiseError("unreachable token");
      }
    } else {
      switch (value.TAG | 0) {
        case /* TokenNumber */0 :
            bumpCurrent(undefined);
            return {
                    TAG: /* Literal */1,
                    _0: {
                      TAG: /* Number */1,
                      _0: value._0
                    }
                  };
        case /* TokenString */1 :
            bumpCurrent(undefined);
            return {
                    TAG: /* Literal */1,
                    _0: {
                      TAG: /* String */0,
                      _0: value._0
                    }
                  };
        case /* TokenName */2 :
            console.log(token);
            return Js_exn.raiseError("unreachable token");
        
      }
    }
  };
  var program = {
    body: []
  };
  while(current.contents < tokens.length) {
    Js_array.push(walk(undefined), program.body);
  };
  return program;
}

function visitProgramChildren(visitor, node) {
  node.body.forEach(function (chlid) {
        Curry._3(visitor.expression, visitor, chlid, {
              TAG: /* Program */0,
              _0: node
            });
      });
}

function visitExpressionChildren(visitor, node) {
  if (node.TAG === /* Call */0) {
    return Curry._3(visitor.callExpression, visitor, node._0, {
                TAG: /* Expression */2,
                _0: node
              });
  } else {
    return Curry._3(visitor.literal, visitor, node._0, {
                TAG: /* Expression */2,
                _0: node
              });
  }
}

function visitCallExpressionChildren(visitor, node) {
  node.params.forEach(function (child) {
        Curry._3(visitor.expression, visitor, child, {
              TAG: /* CallExpression */1,
              _0: node
            });
      });
}

var defaultVisitor_program = visitProgramChildren;

function defaultVisitor_expression(visitor, node, _parent) {
  visitExpressionChildren(visitor, node);
}

function defaultVisitor_callExpression(visitor, node, _parent) {
  visitCallExpressionChildren(visitor, node);
}

function defaultVisitor_literal(_visitor, _node, _parent) {
  
}

var defaultVisitor = {
  program: defaultVisitor_program,
  expression: defaultVisitor_expression,
  callExpression: defaultVisitor_callExpression,
  literal: defaultVisitor_literal
};

var Visit = {
  visitProgramChildren: visitProgramChildren,
  visitExpressionChildren: visitExpressionChildren,
  visitCallExpressionChildren: visitCallExpressionChildren,
  defaultVisitor: defaultVisitor
};

function traverse(ast, visitor) {
  Curry._2(visitor.program, visitor, ast);
}

var CAst = {};

var CAstKind = {};

function transformer(ast) {
  var newAst = {
    body: []
  };
  var contextStack = [];
  var getCurrentContext = function (param) {
    var len = contextStack.length;
    return contextStack[len - 1 | 0];
  };
  var visitor_program = function (vis, node) {
    contextStack.push({
          TAG: /* Program */0,
          _0: newAst
        });
    visitProgramChildren(vis, node);
    contextStack.pop();
  };
  var visitor_expression = defaultVisitor_expression;
  var visitor_callExpression = function (vis, node, _parent) {
    var expression_callee = /* Identifier */{
      _0: node.name
    };
    var expression_arguments = [];
    var expression = {
      callee: expression_callee,
      arguments: expression_arguments
    };
    var context = getCurrentContext(undefined);
    if (context.TAG === /* Program */0) {
      context._0.body.push(/* Expression */{
            _0: {
              TAG: /* Call */0,
              _0: expression
            }
          });
    } else {
      context._0.arguments.push({
            TAG: /* Call */0,
            _0: expression
          });
    }
    contextStack.push({
          TAG: /* CallExpression */1,
          _0: expression
        });
    visitCallExpressionChildren(vis, node);
    contextStack.pop();
  };
  var visitor_literal = function (_vis, node, _parent) {
    if (node.TAG === /* String */0) {
      var v = node._0;
      var context = getCurrentContext(undefined);
      if (context.TAG === /* Program */0) {
        context._0.body.push(/* Expression */{
              _0: {
                TAG: /* Literal */1,
                _0: {
                  TAG: /* String */0,
                  _0: v
                }
              }
            });
        return ;
      }
      context._0.arguments.push({
            TAG: /* Literal */1,
            _0: {
              TAG: /* String */0,
              _0: v
            }
          });
      return ;
    }
    var v$1 = node._0;
    var context$1 = getCurrentContext(undefined);
    if (context$1.TAG === /* Program */0) {
      context$1._0.body.push(/* Expression */{
            _0: {
              TAG: /* Literal */1,
              _0: {
                TAG: /* Number */1,
                _0: v$1
              }
            }
          });
      return ;
    }
    context$1._0.arguments.push({
          TAG: /* Literal */1,
          _0: {
            TAG: /* Number */1,
            _0: v$1
          }
        });
  };
  var visitor = {
    program: visitor_program,
    expression: visitor_expression,
    callExpression: visitor_callExpression,
    literal: visitor_literal
  };
  Curry._2(visitor_program, visitor, ast);
  return newAst;
}

function codeGenerator(node) {
  var emitExpression = function (node) {
    if (node.TAG !== /* Call */0) {
      var node$1 = node._0;
      if (node$1.TAG === /* String */0) {
        return "\"" + node$1._0 + "\"";
      } else {
        return node$1._0;
      }
    }
    var callExp = node._0;
    return "" + callExp.callee._0 + "(" + callExp.arguments.map(emitExpression).join(", ") + ")";
  };
  return node.body.map(function (child) {
                return "" + emitExpression(child._0) + ";";
              }).join("\n");
}

function compiler(input) {
  return codeGenerator(transformer(parser(tokenizer(input))));
}

exports.tokenizer = tokenizer;
exports.LispAst = LispAst;
exports.LispAstKind = LispAstKind;
exports.parser = parser;
exports.Visit = Visit;
exports.traverse = traverse;
exports.CAst = CAst;
exports.CAstKind = CAstKind;
exports.transformer = transformer;
exports.codeGenerator = codeGenerator;
exports.compiler = compiler;
/* No side effect */
